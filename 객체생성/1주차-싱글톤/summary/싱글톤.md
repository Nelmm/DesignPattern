# 

# 싱글톤

> 인스턴스를 오직 한 개만 만들어서 제공하는 클래스가 필요한 경우에 사용하는 패턴

![https://www.notion.so/Users/LeeChnagSup/Library/Application%20Support/marktext/images/2022-03-01-17-45-58-image.png](https://user-images.githubusercontent.com/42997924/143546595-d548b627-e85d-4fed-be93-19ff66eafaa6.png)

즉, 클래스가 최초 한번만 메로리를 할당받고 그 메모리에 인스턴스를 만들어 사용하는 디자인 패턴으로 생성자가 여러 차례 호출되더라도 실제 생성되는 인스턴스는 기존에 생성된 인스턴스이다.

new 를 통해서 생성자를 만들어지면 같지 않은 경우가 생길수 있기 때문에 생성자를 private으로 제한하고 static 메서드를 통해서 생성하도록 해야한다.

## 싱글톤은 언제 사용되는가?

1. **메모리, 속도를 개선해야하는 경우** : 객체의 인스턴스를 재사용하기 때문(고정된 메모리 영역을 사용)
2. **데이터 공유가 필요한 경우** : 기존 인스턴스가 전역으로 사용되기 때문
3. 인스턴스가 **한 개만 존재하는 것을 보장**하고 싶은 경우

추가적으로 싱글톤의 경우 만드는 방식이 점진적으로 발전했었다. 아래 예제 코드에서도 설명하겠으나, 싱글톤을 만드는 방식은 총 6가지 정도 존재한다.

- **이른 초기화 (Eager Initialization)**
  
  static을 통해 전역인스턴스를 만들고, get함수로 불러오는 방식 
  
  - 장점: Thread Safe함.
  
  - 단점: 미리 인스턴스를 만들어놓기 때문에 메모리적 손해

- **늦은 초기화 (Lazy Initialization)**
  
  static으로 선언하지만 미리 선언하지 않고, get함수로 불러올때 생성하는 방식
  
  - 장점: 사용 시점에 인스턴스 생성 메모리 최적화
  
  - 단점: Thread Safe하지 않음.

- **늦은 초기화 + 동기화 (Lazy Initialization with synchronized)**
  
  위의 방식에 sychronized 키워드와 같은 동기화 블록을 활용해 동기화 처리
  
  - 장점: 메모리 효율적인 사용, Thread Safe
  
  - 단점: 인스턴스와 상관없이 Lock걸려서 성능 저하 

- **늦은 초기화 + 더블체킹 락 (Lazy Initialization. Double Checked Locking)**
  
  - 장점: 메모리의 효율적 사용, Thread Safe, 인스턴스 생성 여부 검사(Lock 이슈 해결)
  
  - 단점: 비동기화된 Resource 필드에 의존적 -> 변수의 최신값, 원자성 보장

- **늦은 초기화 + Static Inner Class**
  
  Static inner Class를 만들어서 thread-safe하며, 호출될때 인스턴스가 만들어짐.

- **늦은 초기화 + Enum**
  
  Enum class를 활용하면, 자동으로 singleton 인스턴스가 구성된다.

## 예제 코드

//언제 사용되는지를 가지고 예제 코드를 설명 해줘야 함.

## 패턴의 장/단점

장점:

- 단 한개의 인스턴스를 만드는 클래스를 만들수 있다
- 인스턴스의 글로벌 접근이 가능해진다.
- 싱글톤 객체는 처음 요청이 들어왔을때 딱 한번만 생성된다.

단점:

- SRP(단일 책임원칙)을 위배할 수도 있다.

- 싱글톤 패턴은 나쁜 디자인 패턴이 될수도 있다. 프로그램의 컴포넌트들은 너무 많이 접근할 수 있게되면 안좋을 수도 있다.

- 패턴은 멀티쓰레드 환경에서는 특별한 처리를 요구한다.

- 싱글톤의 클라이언트 코드 유닛테스트가 어려움. 왜냐하면 많은 테스트 프레임워크들이 목객체를 생산할때 상속에 의존적이게 된다.
  
  싱글톤 클래스의 생성자가 private, static method를 오버러이딩한 경우에는 대부분의 언어에서는 불가능함. 그래서 싱글톤 목객체 만드는 방식에 대해서 좀 다시 생각해봐야한다. 혹은 테스트 코드를 작성하지 말던가, 혹은 아예 싱글톤 패턴을 작성하지 않는 방식으로 처리할 수 있다.

## 비슷한 패턴

- **파사드 패턴**: 파사드도 역시 하나의 객체로 충분히 가능한 경우가 많아서, 파사드 패턴 역시 싱글톤으로 변형 가능하다. 

- **플라이웨이트 패턴**: 플라이웨이트 패턴 역시 개체의 모든 공유 상태를 관리할 수 있다는 측면에서는 비슷할 수도 있다. 

       싱글톤 패턴과 약간 다른 점이 존재한다.

       첫째, 싱글톤은 한개의 인스턴스만 가질 수 있지만, 플라이웨이트 패턴의 경우 서로 다른 고유 상태를 가진 인스턴스를 가질 수 있다.

    둘째,  싱글톤 객체는 변형가능하지먼, 플라이웨이트는 변형 불가능하다. 

- **추상팩토리, 빌더, 프로토 타입**의 디자인 패턴 역시 싱글톤으로 구현 가능해진다.