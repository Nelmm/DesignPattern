# 팩토리 메소드

> 다양한 구현체 (Product)가 있고, 그 중에서 특정한 구현체를 만들 수 있는 다양한 팩토리(Creator)를 제공할 수 있다.

![](https://user-images.githubusercontent.com/42997924/144359079-e4f23b8c-d345-49b8-85a5-fd65a1e180ab.png)

부모(상위) 클래스에 알려지지 않은 **구체적 클래스를 생성하는 패턴**이며. 자식(하위) 클래스가 어떤 객체를 **생성할지를 결정하도록 하는 패턴**이기도 하다.

## 팩토리 메소드는 언제 사용되는가?

- 생성할 객체 타입을 예측할 수 없을 때
- **생성할 객체를 기술하는 책임을 서브클래스에게 정의**하고자 할 때
- 객체 생성의 책임을 서브클래스에 위임시키고 **서브클래스에 대한 정보를 은닉**하고자 할 때

## 예제 코드

//언제 사용되는지를 가지고 예제 코드를 설명 해줘야 함.

## 패턴의 장/단점

장점:

- creator 그리고 concreteProduct 간의 긴밀한 복잡도를 피할 수 있다.
- 제품 생성 코드를 프로그램 한 곳으로 이동시켜서 만드는 코드에 대해서 쉽게 유지 보수가 가능해진다. SRP(단일 책임 원칙)의 역할을 잘지킨 Case
- 기존 클라이언트 코드를 건들지 않고도 새로운 코드를 추가가능해진다. OCP(개방-폐쇄 원칙)를 잘 지킨 Case

단점:

- Code 자체의 복잡도가 증가한다. 이패턴을  적용하기위해서는 서브 클래스를 많이 도입할 수 밖에 없기 때문에, 가장 베스트 케이스인 기존 Creator 클래스 계층에 이 패턴을 사용하는 경우가 아니라면, 많이 복잡해질 수 있다.

## 비슷한 패턴

- **추상 팩토리 패턴, 프로토 타입 패턴, 빌더패턴**이 더 유연하고, 더 복잡한 방식으로 팩토리 메소드 패턴에서 발전한 패턴이다.

- **추상 팩토리** 패턴은 팩토리 메소드의 집합을 기반으로 되어있다. 비슷하게 프로토타입의 경우는 이런 클래스들의 메소드들을 구성해서 사용해야 한다.

- **이터레이터** 패턴과 함께 팩토리 메소드 패턴을 사용하면, Collection들과 호환되는 여러 유형의 다른 이터레이터들을 반환할 수 있도록할 수 있다. 

- **프로토 타입** 패턴은 상속을 기반으로 하지 않아서, 결점이 없으나 프로토타입 패턴은 복사된 객체의 복잡한 초기화가 필요하다. 반면, 팩토리 메소드 패턴의 경우는 상속기반이지만, 복잡한 초기화는 필요 없다.

- **템플릿 메소드 패턴**은 팩토리 메소드 패턴에서 분화되어서 나왔으며, 큰 탬플릿 메소드의 단계적 역할을 팩토리 메소드가 맡을 수 있다.


