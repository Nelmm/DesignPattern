# 중재자 패턴

> 객체 간의 **직접 통신**을 제한하고 중재자 객체를 통해서만 협력하도록 하는 패턴

![](https://refactoring.guru/images/patterns/diagrams/mediator/structure.png)

****Components****: 비즈니스 로직을 포함하고 있는 다양한 클래스

**Mediator**: 컴포넌트와의 통신 방식을 선언하는 인터페이스

**Concrete Mediators**: 여러 컴포넌트 사이간의 관계를 캡슐화함. 

## 중재자는 언제 사용되는가?

- 클래스가 다른 클래스와 밀접하게 연결되어 있어 일부 클래스를 변경하기 어려운 경우

- 커플링이 심해 클래스를 다른 프로그램에서 재사용하기 어려운 경우

## 중재자 패턴 예제 코드



## 패턴의 장/단점

✅ 장점:

- SRP(단일 책임 원칙) 한 장소에서 더 쉽게 다양한 컴포넌트들에 대한 통신을 추출 가능해짐.  
- OCP(개방/폐쇄 원칙) 실제 컴포넌트를 변경없이도 새로운 중재자를 추가할 수 있다.
- 프로그램의 다양한 컴포넌트들 간의 커플링을 줄일 수 있다.
- 개별적인 컴포넌트를 더 쉽게 재사용 가능해진다. 

🚨 단점:

- 자칫잘못하면 중제자가 신의 객체가 되어 버릴 수 있다.

## 비슷한 패턴

- **책임연쇄패턴, 커맨드패턴, 중제자, 옵저버**는 요청에 대한 발송자와 수신자 연결 방식이 다양하다
  
  - **책임연쇄패턴**은 잠재적인 리시버중 하나가 처리될때까지 요청을 동적인 리시버체인에 따라서 순차적인 처리를 한다. 
  
  - **커맨드 패턴**은 수신자와 송신자 사이의 단방향의 연결을 설립한다.
  
  - **중재자 패턴**은 송신자와 수신자를 직접적인 통신은 배제하고 중제자 객체를 통한 간접적인 소통 가능하도록 강제한다.
  
  - **옵저버 패턴**은 수신자의 전달받은 요청으로부터 동적으로 구독하거나 비구독하는 방식으로 구성한다

- **파사드와** **중재자**는 비슷한 작업을 한다. 밀접하게 커플링된 클래스들간 사이에서 협업을 조직하는 방식으로 구성함.
  
  - **파사드는** 객체 서브시스템에 대한 단순한 인터페이스를 정의하지만, 새로운 기능을 도입하지는 않음. 서브 시스템에서 파사드를 인식시킬 수 는 없고, 서브 시스템 내의 객체끼리는 직접 통신이 가능함. 
  
  - **중재자는** 시스템의 컴포넌트들을 중앙 집중화시킨다. 그 컴포넌트들은 중재자 객체만 알고 직접적으로 통신하지는 않음. 
